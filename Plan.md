Тогда погнали оформлять это как нормальный архитектурный документ, который не стыдно кинуть в репозиторий.

---

## 1. Цель и роль модуля Network

**Назначение**:
Отдельный multiplatform-модуль `network`, отвечающий за:

* Унифицированный доступ к сети для core-части проекта.
* Поддержку REST, WebSocket и HTTP SSE.
* Централизованную авторизацию, логирование, кэширование, метрики.
* Механизмы расширения (плагины, пер-запросные конфигурации).

**Границы**:

* Работает только в core-слое.
* Не переключает контексты корутин — ответственность Repository / DataSource.
* Не знает об бизнес-логике и фичах, только о транспорте и протоколах.
* Основан на Ktor Client, но скрывает детали его конфигурации за абстракциями.

**Зависимости**:

* Foundation-модуль: AppError, AppResult, SafeCall, логгер.
* coroutines, kotlinx.serialization, ktor, koin.
* Дополнительно (по желанию): atomicfu, datetime — для внутренней реализации.

---

## 2. Общий обзор архитектуры

Слои внутри модуля `network`:

1. **Core Transport Layer**

   * Фабрика HttpClient и engines.
   * Общие плагины (логирование, кэш, метрики, базовые мапперы ошибок).
   * Управление форматом данных (JSON/ProtoBuf).

2. **Protocol Layer**

   * RestClient — синхронные/одноразовые HTTP-запросы.
   * WebSocketClient — двусторонний поток сообщений.
   * SseClient — односторонний стрим событий по SSE.
   * Каждому протоколу — свой набор конфигураций и плагинов.

3. **Policy & Plugins Layer**

   * Авторизация (несколько схем).
   * Ретраи, кэширование, пагинация (как отдельные подключаемые плагины).
   * Внешние мапперы ошибок и интерцепторы.

4. **Public API Layer**

   * Интерфейсы и фабрики, которые будут использовать DataSource-ы:

     * RestClientFactory
     * WebSocketClientFactory
     * SseClientFactory
     * NetworkConfig (глобальная и локальная конфигурация)

DataSource в своих DI-модулях:

* получают через Koin фабрики/абстракции из `network`;
* создают верхнеуровневые клиентов под свои baseUrl и нужные схемы авторизации/плагины.

---

## 3. Пакетная структура модуля

Рекомендуемая структура пакетов:

* `network.core`

  * базовые интерфейсы и общие типы (NetworkConfig, NetworkPlugin, NetworkEnvironment и т.п.)
* `network.http`

  * HttpClientFactory, HttpEngineFactory, общие HTTP-плагины
* `network.rest`

  * RestClient, RestRequest, RestResponse, RestConfig, плагины для пагинации, кэша и т.п.
* `network.websocket`

  * WebSocketClient, WebSocketConfig, типы сообщений и событий
* `network.sse`

  * SseClient, SseConfig, SseEvent, механизмы reconnection/Last-Event-Id
* `network.auth`

  * схемы авторизации, TokenProvider-интерфейсы, плагины авторизации
* `network.error`

  * маппинг ошибок в AppError, интерфейсы внешних мапперов/интерцепторов
* `network.logging`

  * интеграция с общим логгером, адаптеры логов Ktor → AppLogger
* `network.metrics`

  * сбор метрик, контракты для внешних систем
* `network.cache`

  * кэш-плагин поверх HTTP, стратегии кэширования
* `network.connectivity` (по желанию в отдельный модуль)

  * интерфейсы для проверки доступности сети

---

## 4. Базовые принципы API

1. Все публичные операции сети возвращают AppResult:

   * для REST — AppResult<T>;
   * для WebSocket/SSE — Flow с элементами, инкапсулирующими AppResult либо события/ошибки отдельно.
2. Исключения наружу не выбрасываются — перехватываются SafeCall-функциями и маппятся в AppError.
3. BaseUrl всегда передаётся рядом с path при создании клиентов или построении запроса.
4. Конфигурация по умолчанию минималистичная, дополнительные политики включаются через плагины.

---

## 5. Конфигурация и фабрики

### 5.1. NetworkConfig

Единая точка настройки модуля:

* Настройки сериализации:

  * JSON-конфигурация (ignore unknown keys, coercion, и т.п.).
  * Опциональные форматы (ProtoBuf и др.).
* Настройки безопасности:

  * certificate pinning (опционально),
  * кастомные сертификаты,
  * общие security-headers (например, User-Agent, X-Platform, X-App-Version).
* Настройки логирования (уровень детализации).
* Подключаемые глобальные плагины:

  * глобальные мапперы ошибок,
  * глобальные метрики,
  * глобальные политики кэширования (если нужны по умолчанию).

NetworkConfig должен быть иммутабельным и лёгким для передачи.

### 5.2. HttpClientFactory

Фабрика для создания Ktor HttpClient:

* Принимает:

  * NetworkConfig,
  * список плагинов/интерцепторов,
  * конфигурацию engine (различную для Android/iOS/Desktop, скрытую за интерфейсом).
* Отвечает за:

  * подключение сериализации,
  * базовое логирование HTTP,
  * настройки тайм-аутов по умолчанию,
  * интеграцию с AppError-мапперами.

Дальше RestClient/WebSocketClient/SseClient используют уже сконфигурированный HttpClient.

---

## 6. REST подсистема

### 6.1. RestClient и RestRequest

RestClient — абстракция над Ktor для REST:

* Работает с baseUrl и относительными path.
* Поддерживает HTTP-методы (GET, POST, PUT, DELETE и т.д.).
* Возвращает AppResult<T>.

RestRequest:

* Содержит:

  * baseUrl,
  * path (относительный),
  * HTTP-метод,
  * query-параметры,
  * заголовки,
  * тело (опционально),
  * ожидания по формату ответа (JSON/ProtoBuf/текст/файл).
* Строится через DSL:

  * декларативное описание query, headers, body, auth-политики и плагинов для конкретного запроса.
* Поддерживает пер-запросную конфигурацию:

  * override тайм-аутов,
  * включение/выключение кэширования,
  * подключение доп. мапперов ошибок.

### 6.2. Ответы и обработка

RestResponse (внутренний тип):

* Инкапсулирует HTTP-статус, заголовки, «сырое» тело.
* Не выходит наружу напрямую, но используется для:

  * логирования,
  * метрик,
  * маппинга ошибок.

Публичный результат — AppResult<T>:

* В случае успеха содержит десериализованное тело.
* В случае ошибки —

  * AppError.Network / AppError.Http / AppError.Serialization / AppError.Unknown,
  * плюс опциональные данные из боди ошибки, если подключены соответствующие мапперы.

### 6.3. Плагин пагинации

Отдельный подключаемый плагин:

* Предоставляет типовые сценарии:

  * page/limit,
  * cursor-based.
* Не зашит в RestClient, а подключается на уровень DataSource:

  * DataSource может использовать RestClient для «сырых» запросов и подключать плагин пагинации для унификации работы со страницами.

---

## 7. WebSocket подсистема

### 7.1. WebSocketClient

Контракт:

* Метод подключения, который возвращает поток событий (Flow), представляющих входящие сообщения и события соединения.
* Методы отправки сообщений (внутренний интерфейс, но публично доступный объект/handle подключения).

Особенности:

* Поддержка строковых и бинарных сообщений.
* Сериализация/десериализация JSON через kotlinx.serialization, если типизированные сообщения.
* Возможность работать и на уровне «сырых» payload, и на уровне DTO.

### 7.2. Конфигурация и реконнект

WebSocketConfig:

* Параметры reconnection:

  * максимальное количество попыток,
  * стратегия бэкоффа (например, линейный/экспоненциальный),
  * паузы между попытками.
* Политика ошибок:

  * какие типы ошибок приводят к автоматическому переподключению,
  * какие — к окончательному закрытию.

События:

* Подключение/подключено/ошибка/закрытие/переподключение и т.д.
* Ошибки сигнализируются через события/результаты внутри Flow (без выброса исключений наружу).

---

## 8. SSE подсистема

### 8.1. SseClient

Контракт:

* Метод, возвращающий Flow SseEvent<T>:

  * T — тип данных внутри data-поля SSE (обычно JSON).
* Поддерживает:

  * стандартный формат event/id/data,
  * текстовый формат с парсингом.

### 8.2. Reconnection и Last-Event-Id

* Поддержка автоматического переподключения с использованием Last-Event-Id.
* Политики reconnection аналогичны WebSocketConfig.
* Возможность хранения Last-Event-Id:

  * в памяти клиента,
  * опционально передавать извне (например, пользователь сам сохраняет последнюю обработанную id).

---

## 9. Авторизация

### 9.1. Схемы авторизации

Поддерживаемые схемы:

* API key (в заголовках или query).
* Bearer-токен (access token).
* OAuth (на уровне применения токенов, а не протокола авторизации целиком).

Реализуется через:

* абстракции для TokenProvider:

  * синхронный или suspend-поставщик текущего токена.
* плагины авторизации, которые:

  * добавляют нужные заголовки/параметры к запросам,
  * могут быть подключены per-client или per-request.

### 9.2. Обновление токенов

Механика:

* По умолчанию Network ничего сам не обновляет.
* Предоставляется интерфейс для интеграции механизма refresh:

  * DataSource или фича может предоставить реализацию, которая:

    * реагирует на 401/403,
    * инициирует обновление токена,
    * повторяет запрос.
* Также возможно предложить готовый встроенный плагин «авто-refresh»:

  * который потребитель может явно включить для конкретного клиента.

Таким образом, «автоматически только если потребитель это выбрал» реализуется через явное подключение плагина.

---

## 10. Ошибки и внешние мапперы

### 10.1. Базовый маппинг

В модуле `network.error`:

* Маппинг низкоуровневых ошибок:

  * отсутствие сети / DNS / connection refused → AppError.Network;
  * тайм-аут → AppError.Network/Timeout;
  * SSL-проблемы → AppError.Security/Certificate;
  * HTTP-коды:

    * 4xx → AppError.Http.ClientError,
    * 5xx → AppError.Http.ServerError,
    * прочее → AppError.Http.Unknown.
* Ошибки сериализации → AppError.Serialization.

Все ошибки проходят через SafeCall-функции Foundation.

### 10.2. Внешние мапперы и интерцепторы

Предоставляется возможность:

* зарегистрировать один или несколько внешних error-mapper’ов:

  * принимают HTTP-ответ + необработанную ошибку,
  * могут:

    * распарсить error-body backend’а,
    * вернуть более специфичный AppError (например, ValidationError, BusinessRuleError).
* интерцепторы ошибок:

  * слушают все ошибки,
  * могут логировать/отправлять метрики/уведомлять внешние системы.

Регистрация мапперов и интерцепторов — через конфигурацию клиентов или NetworkConfig.

---

## 11. Логирование и метрики

### 11.1. Логирование

Интеграция с существующим логгером:

* Для каждого запроса/ответа логируются:

  * метод, URL (без чувствительных параметров),
  * статус-код,
  * время выполнения,
  * размер тела (если возможно).
* Уровни логирования маппятся на уровни логгера:

  * debug — детальная информация, включая headers и тела (с ограничениями по безопасности),
  * info — основные данные запроса/ответа,
  * error — ошибки и исключения.

Безопасность:

* Возможность отключать логирование тела для:

  * авторизационных запросов,
  * запросов с потенциально чувствительными данными,
  * бинарных payload’ов.
* Эти политики конфигурируются через NetworkConfig и/или пер-клиент.

### 11.2. Метрики

В `network.metrics`:

* Сбор базовых метрик:

  * время ответа по endpoint-ам,
  * количество успешных/ошибочных запросов,
  * распределение типов ошибок.
* Интерфейс для экспорта метрик:

  * к внешним системам (Sentry, Crashlytics, собственный backend).
* Метрики не навязаны: включаются по желанию, через подключаемую реализацию.

---

## 12. Сериализация и форматы данных

* JSON через kotlinx.serialization — формат по умолчанию:

  * опции JSON-конфига задаются в NetworkConfig.
  * naming управляется через аннотации моделей (@SerialName).
* Возможность подключения ProtoBuf или другого формата:

  * конфигурация на уровне клиента или пер-запрос.
  * выбор сериализатора по типу контента.

Дополнительно:

* Поддержка multipart/form-data:

  * отдельный DSL-плагин для сборки multipart-запросов.
* Работа с plain text / HTML:

  * специальные хэндлеры ответов, которые не требуют сериализации.
* Стриминг файлов:

  * API для скачивания в поток (например, в файл на диске, предоставленный вызывающей стороной),
  * избегая хранения всего содержимого в памяти.

---

## 13. Кэширование

В `network.cache`:

* Собственный кэш-плагин поверх HTTP:

  * поддержка ETag/If-None-Match, Last-Modified/If-Modified-Since.
  * возможность кэшировать по ключу (method + URL + query).
* Политики кэширования:

  * глобальная (по умолчанию),
  * пер-запрос/пер-клиент, задаваемая в DSL.
* Кэш-хранилище:

  * абстракция над storage (in-memory или другое хранилище),
  * конкретная реализация выбирается на уровне приложения.

---

## 14. Проверка сети (connectivity)

Рекомендуется вынести отдельным модулем core, но Network использует интерфейс:

* Интерфейс ConnectivityChecker:

  * возвращает текущее состояние (online/offline),
  * может давать поток изменений.
* В Network:

  * при offline-состоянии запрос может сразу завершаться AppError.Network/Offline,
  * включается по желанию (через конфигурацию клиента).

---

## 15. DI (Koin) и интеграция

### 15.1. Koin-модуль network

Модуль `network` экспортирует:

* NetworkConfig (singleton).
* HttpClientFactory.
* Фабрики:

  * RestClientFactory,
  * WebSocketClientFactory,
  * SseClientFactory.
* Регистрацию глобальных error-mapper’ов, логирования, метрик.

### 15.2. DataSource-модули

Каждый DataSource-модуль:

* импортирует network-модуль Koin.
* создаёт свои верхнеуровневые клиентов:

  * задаёт baseUrl своего backend-а,
  * подключает нужные плагины:

    * auth-схемы и TokenProvider,
    * pagination-плагин,
    * кэш-политику,
    * авто-refresh токена (если нужно),
    * дополнительные error-mapper’ы конкретного backend-а.

---

## 16. Тестирование и мокирование

* Все публичные клиенты (RestClient, WebSocketClient, SseClient) описаны интерфейсами.
* Реализация на Ktor — одна из реализаций.
* Для тестов:

  * фейковые реализации, работающие с JSON-фикстурами,
  * возможность подмены HttpClientFactory на тестовую (например, Ktor MockEngine).
* Это позволяет тестировать DataSource/Repository без реальной сети.

---

На выходе получаем модуль Network, который:

* Ясно разделяет транспорт, протоколы и политики.
* Не лезет в потоки и бизнес-логику.
* Опирается на Foundation (AppResult/AppError/SafeCall/логгер).
* Масштабируется под несколько baseUrl, несколько схем авторизации и разные типы клиентов.
* Конфигурируется через DI и плагины, а не магическими флагами.

Дальше можно поверх этого писать конкретные интерфейсы RestClient/WebSocketClient/SseClient и прописывать Koin-модуль — всё уже определено на уровне архитектуры.
