# ADR-2025-11-21 — Переход на мультимодульную архитектуру KMP

Статус: Accepted
Дата: 2025-11-21
Автор: Cline (по запросу владельца проекта)
Область: Архитектура, Gradle, KMP, DevEx, Контроль зависимостей

## Контекст

Текущий репозиторий содержит:
- Фронтенд Compose Multiplatform приложение в модуле `:composeApp` (Android + Desktop/JVM).
- Общую логику в монолитном модуле `:shared`.
- Сервер Ktor в модуле `:server`.

Цели:
- Ввести чёткую мультимодульную архитектуру с изоляцией слоёв и разрезом по фичам.
- Обеспечить единые контракты данных/роутинга/ошибок между клиентом и сервером.
- Запретить горизонтальные зависимости между фичами.
- Удерживать единый toolchain (Java Toolchain 21), унифицированные версии Kotlin/Compose (libs.versions.toml).
- Поддерживать KMP таргеты: Android, iOS, JVM(Desktop).
- Использовать Room KMP строго в `commonMain` (это жёсткое требование) с корректной конфигурацией KSP для всех таргетов.
- Ввести контроль зависимостей (jdeps + Graphviz) с fail-политикой при нарушениях.

Ограничения:
- Существующий код уже использует Ktor Client/Server, kotlinx.serialization, Koin, Compose Multiplatform.
- Имеется серверный модуль `:server`, который сейчас тянет `:shared` напрямую — необходимо разорвать зависимость на реализацию в пользу контрактов.
- Необходимо минимизировать регресс в рантайме при постепенной миграции.

## Решение (Decision)

Вводится новая топология модулей и правила зависимостей.

### Топология модулей

Группы модулей (namespaces):
- `:shared`
  - `:shared:core:*` — общие базовые абстракции (константы, ошибки, базовые утилиты, сериализация, типы-значения), не зависящие от фич.
  - `:shared:contracts:*` — контракты API/DTO/роутинга/ошибок, разделяемые между фронтом и бэком. Не содержит платформенных или UI-зависимостей. Только `commonMain`.
- `:frontend`
  - `:frontend:core:*` — фронтовые базовые слои (навигация-контракты, UI-темы, platform adapters, DI-агрегаторы для фронта).
  - `:frontend:features:<feature>:api` — API фичи: модели, интерфейсы use-cases, внешние контракты навигации для фичи, без реализации.
  - `:frontend:features:<feature>:impl` — реализация фичи (UI, ViewModel, репозитории, интеграции), зависит на `:frontend:features:<feature>:api`, `:shared:*` и `:frontend:core:*`. Горизонтальные зависимости на другие фичи запрещены.
- `:backend`
  - `:backend:core:*` — базовые серверные модули (конфигурация Ktor, сериализация, DI для сервера).
  - `:backend:features:<feature>:api` — контракты серверной фичи (handler interfaces), синхронизированы по моделям с `:shared:contracts`.
  - `:backend:features:<feature>:impl` — реализация серверной фичи, зависит на `:backend:features:<feature>:api`, `:shared:*`, `:backend:core:*`.
- `:instances`
  - `:instances:frontend:<platform>` — инстансы приложений (например, `android`, `desktop`). Содержат точку входа, wire-up DI, навигацию, сборку нужных фич.
  - `:instances:servers:<server>` — серверные инстансы, собирающие `:backend:*` скоуп.

Рефакторинг текущих модулей:
- `:composeApp` → `:instances:frontend:android` и `:instances:frontend:desktop` (или оставить как единый MPP-инстанс с платформенными сорс-сетами).
- `:server` → `:instances:servers:mcp`, перенастроить зависимости на `:backend:*` и `:shared:contracts:*`.
- `:shared` будет декомпозирован на `:shared:core:*` и `:shared:contracts:*`. Логика, ранее общая и «реализационная», будет перемещена в соответствующие `:frontend:*`/`:backend:*`.

### Правила зависимостей

Инварианты:
1) Горизонтальные зависимости запрещены:
   - `:frontend:features:A:impl` не может зависеть от `:frontend:features:B:impl`.
   - Общение между фичами только через их `:api` и общие оркестратор/мост(bridge).

2) Вертикальные зависимости разрешены вниз по слоям:
   - `impl` → `api`, `core`, `shared:contracts`, `shared:core`.
   - `api` не зависит от `impl`.
   - `instances` зависятся от `api`/`impl` фич, `core`, `shared:*`, но не экспортируют реализацию наружу.

3) Сервер не может зависеть от фронтовых модулей:
   - `:instances:servers:*` и `:backend:*` зависят от `:shared:contracts:*` и `:shared:core:*`, но не от `:frontend:*`.

4) Общие контракты:
   - DTO, ошибки, контракты роутинга и версионирования — в `:shared:contracts:*`.
   - Любая сетевая модель, используемая и на клиенте, и на сервере — источник истины в `:shared:contracts:*`.

5) Таргеты KMP:
   - Android, iOS, JVM(Desktop). Для iOS — подготовленные sourceSets и зависимостные ограничения без платформенной реализации в common модулях, где это возможно.

6) Room KMP:
   - Строго в `commonMain`. Конфигурация KSP многотаргетная. На JVM — `sqlite-bundled`.
   - Схемы для миграций лежат в `module/schemas`.

7) DI:
   - Koin. Границы DI-модулей повторяют границы Gradle-модулей. Агрегатор конечных модулей: `root`.

8) Ошибки и политика fail-fast:
   - Единая `DomainException` в `:shared:core:exceptions`.
   - `safeApiCall` в `:frontend:core:common`
   - Билд падает при нарушении зависимостных правил (jdeps).

### Toolchain и Gradle-конвенции

- Единый Java Toolchain = 21 для всех модулей (KMP/Server/Desktop).
- Версии Kotlin/Compose/AGP/Ktor/Room — в `gradle/libs.versions.toml`.
- Вводим convention-плагины (через build-logic или buildSrc):
  - `aichallenge.library` — для обычных библиотек KMP.
  - `aichallenge.compose` — для UI/Compose MPP модулей.
  - `aichallenge.server` — для серверных модулей/инстансов.
- Включаем `TYPESAFE_PROJECT_ACCESSORS` и используем `projects.*`.
- Контроль зависимостей:
  - Задачи Gradle на `jdeps`, формирование DOT, визуализация через Graphviz.
  - CI-правило: при наличии недопустимых зависимостей — fail.

### Данные и Persist

- Room KMP в `commonMain`.
- KSP конфигурация:
  - Включаем `kspCommonMainMetadata` и платформенные конфигурации (`kspAndroid`, `kspJvm`, при необходимости для iOS через соответствующие конфиги/плагины по поддержке в момент интеграции).
  - JVM: добавляем зависимость `sqlite-bundled`.
  - Схема миграций: `room { schemaDirectory("$projectDir/schemas") }`.
- DataStore (Preferences/Proto) — только во фронтенд модулях при необходимости.

### Сеть

- Клиент: Ktor Client (`contentNegotiation`, `websockets`), kotlinx.serialization.
- Сервер: Ktor Server (`netty`), DTO только через `:shared:contracts`, роутинг через специальныйроутер.
- Версионирование API: через пакет в `:shared:contracts` и префиксы путей.

### Навигация (Frontend)

- Контракты навигации/роуты: в `:frontend:core:navigation` (контракты маршрутов без UI), экраны в `:frontend:features:<feature>:impl`.
- Экспозиция «точек входа» фич — через `:api` модуль фичи.

### Логирование и метрики

- Разделить API и реализации:
  - `logging:api` (интерфейсы и модели логов/метрик).
  - `logging:impl-frontend`, `logging:impl-backend`.
- Маршрутизация логов платформенно-зависимая через DI.

## План миграции (этапы)

Этап 0 — Базовая инфраструктура:
- Ввести convention-плагины (`aichallenge.library`, `aichallenge.compose`, `aichallenge.server`).
- Выравнять Java Toolchain = 21.
- Свести версии в `libs.versions.toml`.
- Добавить задачи `jdeps` и отчёты.

DoD Этапа 0:
- Все модули собираются с Java 21.
- Конвенции подключены минимум к 1-2 модулям.
- Есть `jdeps` задача и генерация DOT.

Этап 1 — Ядро:
- Создать `:shared:core:*`, `:frontend:core:*`, `:backend:core:*`.
- Вынести константы, ошибки, сериализацию, базовые утилиты.

DoD Этапа 1:
- Базовые типы изолированы, проект собирается.

Этап 2 — Контракты:
- Создать `:shared:contracts:*` (DTO, ошибки API, роуты).
- Перевести сервер и фронт на использование контрактов.

DoD Этапа 2:
- Сервер НЕ зависит от реализации `:shared`, только от контрактов и core.

Этап 3 — Экстракция фич:
- По очереди: metrics → settings → reminder → mcp → chat.
- Для каждой фичи: `:frontend:features:<feature>:{api,impl}` и при необходимости `:backend:features:<feature>:{api,impl}`.
- Устранить горизонтальные зависимости.

DoD Этапа 3:
- Для каждой фичи: API/IMPL разделены, зависимости строго валидны.

Этап 4 — Инстансы:
- `:instances:frontend:android`, `:instances:frontend:desktop` (или единый MPP-инстанс с платформенными sourceSets).
- `:instances:servers:ktor` вместо `:server`.

DoD Этапа 4:
- Приложение и сервер поднимаются из инстансов, зависят от контрактов и core.

Этап 5 — CI/QA:
- Верификация jdeps-правил на CI.
- Линтеры, тесты, Smoke для фич.
- Репорты зависимости/размеров/метрик.

DoD Этапа 5:
- CI падает при нарушениях инвариантов.
- Бейдж статуса и артефакты отчётов.

## Критерии готовности (общие DoD)

- Запрещены горизонтальные зависимости (jdeps подтверждает).
- Сервер зависит от `:shared:contracts:*` и `:shared:core:*` (не от фронта).
- Все модули на Java 21, версии управляются через `libs.versions.toml`.
- Room KMP работает из `commonMain` с корректным KSP на всех поддерживаемых таргетах, схемы миграций формируются.
- Навигация и контракты вынесены из UI-реализаций в соответствующие `:api`/`:contracts`.
- Логи/метрики разведены на API и платформенные реализации.

## Риски и смягчения

- Сложность KSP/KMP-конфигурации Room:
  - Использовать проверенные версии Room KMP и ksp конфигурации для `commonMain`.
  - Автотест миграций схем на JVM.

- Временная деградация модульной чистоты во время миграции:
  - Переезд по фичам с промежуточными адаптерами.
  - Jdeps в режиме «warning» во время перехода и «fail» после DoD Этапа 3.

- Версионирование контрактов:
  - Вводить семвер-папки/пакеты в `:shared:contracts` при необходимости.

## Последствия

- Улучшается изоляция, ускоряется сборка, появляется масштабируемость по фичам и платформам.
- Чёткие контракты уменьшают связность между фронтом/бэком.
- Строгие правила зависимостей повышают качество и снижают риски деградации архитектуры.

## Альтернативы

- Оставить монолит `:shared` и межфичевые зависимости — отвергнуто из-за сложности развития и тестирования.
- Использовать один уровень «features» без `api/impl` — отвергнуто, т.к. ухудшает стабильность контрактов.

## План внедрения

- Следовать по этапам 0→5.
- Начать с обновления memory bank (текущий шаг), затем внедрить build-конвенции, затем ядро, контракты, фичи, инстансы, CI/QA.
