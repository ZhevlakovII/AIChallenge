# Документ по принципам и стилю проекта AIChallenge

## 1. Архитектурные принципы

### 1.1. Общая архитектура
- Проект следует принципам **чистой архитектуры** с четким разделением на слои:
  - **Presentation**: UI-компоненты, ViewModel, состояния
  - **Domain**: бизнес-логика, use cases, доменные модели
  - **Data**: реализации репозиториев, источники данных, DTO-модели
- Используется **модульный подход** с разделением на feature-модули
- Соблюдается **принцип инверсии зависимостей** (Dependency Inversion Principle)
- Применяется **паттерн MVI** (Model-View-Intent) для UI
- Используется **реактивное программирование** с применением StateFlow

### 1.2. Мультиплатформенность
- Код организован с учетом **Kotlin Multiplatform**
- Общий код выделен в `shared` модуль
- Платформенная специфика изолирована в соответствующих source sets

## 2. Технологический стек

### 2.1. Основные технологии
- **Kotlin Multiplatform**: основной язык программирования
- **Compose Multiplatform**: для создания UI
- **Ktor**: для сетевого взаимодействия
- **Koin**: для внедрения зависимостей
- **Kotlinx.serialization**: для сериализации/десериализации данных
- **Kotlin Coroutines**: для асинхронного программирования

### 2.2. Особенности использования
- Коллекции состояний реализуются с помощью StateFlow
- Асинхронные операции выполняются в корутинах с явным указанием диспетчера
- Используются корутинные скоупы для управления жизненным циклом

## 3. Структура проекта

### 3.1. Модульная организация
- **composeApp**: UI-компоненты, навигация, ViewModels
- **shared**: общий код, доменная логика, репозитории, модели данных
- **server**: серверная часть приложения

### 3.2. Организация фичей
- Каждая фича имеет свой пакет с подпакетами:
  - **di**: модули Koin для внедрения зависимостей
  - **domain**: use cases и доменные модели
  - **presentation**: ViewModels, UI-состояния, события и UI-компоненты
  - **data**: репозитории и источники данных

## 4. Соглашения по именованию и стилю кода

### 4.1. Именование
- **Классы**: UpperCamelCase, отражают назначение (например, `ChatViewModel`)
- **Интерфейсы**: без префикса 'I', описывают функциональность (например, `OpenAIApi`)
- **Реализации интерфейсов**: с суффиксом 'Impl' (например, `OpenAIApiImpl`)
- **DTO-модели**: с суффиксом 'DTO' (например, `ChatMessageDTO`)
- **Use Cases**: глагол + существительное (например, `SendMessageUseCase`)
- **Константы**: UPPER_SNAKE_CASE

### 4.2. Документирование
- KDoc комментарии на **русском языке**
- Документирование всех публичных API, классов и методов
- Документирование неочевидных решений в сложных методах

### 4.3. Стиль кода
- Предпочтение **неизменяемым** структурам данных (data classes, immutable collections)
- Использование **extension-функций** для расширения функциональности
- Обработка ошибок через **специализированные классы ошибок**
- Явное логирование всех ключевых операций и ошибок

## 5. Работа с данными

### 5.1. Модели данных
- Четкое разделение **доменных моделей** и **DTO-моделей**
- Использование **маппера** для преобразования между моделями разных слоев
- Избегание использования DTO в презентационном слое

### 5.2. Хранение данных
- Инкапсуляция логики доступа к данным в **репозиториях**
- Использование **абстракций** для источников данных
- Персистентность данных для поддержки offline-режима

## 6. Взаимодействие с API

### 6.1. Конфигурация
- Использование **интерфейсов** для API-клиентов
- Конфигурирование API-клиентов через DI
- Обработка API-ключей с соблюдением безопасности

### 6.2. Обработка ошибок
- Специализированные классы ошибок для различных сценариев
- Информативные сообщения об ошибках
- Логирование деталей запросов и ответов для отладки

## 7. Состояние и интерфейс пользователя

### 7.1. Управление состоянием
- Использование **UI-моделей состояния** для представления данных в UI
- Однонаправленный поток данных (MVI)
- Обновление UI через StateFlow

### 7.2. Обработка событий
- События от UI обрабатываются через паттерн **событий** (events)
- Четкое разделение между событиями, состоянием и эффектами

## 8. Логирование и отладка

### 8.1. Принципы логирования
- Использование разных уровней логирования (debug, info, error)
- Структурированное логирование с контекстом
- Логирование важных бизнес-событий и ошибок

### 8.2. Диагностика
- Сбор и анализ метрик использования
- Мониторинг потребления ресурсов (токены, сетевые запросы)

## 9. Документация и синхронизация

Обязательство: любые изменения архитектурных принципов, правил генерации кода, структуры путей или процессов разработки должны быть синхронизированы между .clinerules (источник для IDE Cline) и публичной документацией в docs/*.

- Источник истины:
  - Для IDE: директория .clinerules (используется Cline).
  - Для команды/пользователей: docs/human/* и docs/llm/*.
- Парные документы, подлежащие синхронизации:
  - .clinerules/LLM-CodeGenerationRules.md ⇄ docs/llm/code_generation_rules.md
  - .clinerules/LLM-FilePathsPolicy.md ⇄ docs/llm/file_paths_policy.md
  - .clinerules/Project-rules.md ⇄ docs/human/{Architecture.md,ProjectStructure.md,CodingStandards.md,FeatureDevelopmentGuide.md}
  - При изменении моделей/ошибок/процессов: docs/human/{ErrorHandling.md,API-Networking.md,Data-Persistence.md,Logging-Metrics.md,TestingStrategy.md,Security.md}
- Процесс синхронизации (обязателен в каждой задаче/PR):
  1) Обновить соответствующие парные документы.
  2) Перепроверить и актуализировать кросс-ссылки (INDEX, ссылки внутри файлов).
  3) Обновить docs/INDEX.md и при необходимости docs/inventory/project_inventory.json.
  4) В описании PR добавить чек-лист:
     - [ ] .clinerules ↔ docs/llm синхронизированы
     - [ ] .clinerules ↔ docs/human синхронизированы (если релевантно)
     - [ ] INDEX обновлён
     - [ ] Inventory актуален (если затронуты пути/файлы)
  5) Префикс коммита: [docs-sync] с перечислением затронутых документов.
- Валидация:
  - Тексты не должны противоречить друг другу; пути и имена файлов — фактическим.
  - Примеры/шаблоны соответствуют политике путей и текущему коду.
- Ответственность:
  - Автор изменений отвечает за двустороннюю синхронизацию и обновление индекса/инвентаря до слияния.
