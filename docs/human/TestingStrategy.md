# Стратегия тестирования

Документ описывает подход к тестированию проекта AIChallenge с учётом KMP+CMP, Чистой архитектуры, MVI, Koin, Ktor, Coroutines, Kotlinx.serialization. Согласован с AIChallenge-StyleGuide.md, .clinerules/Project-rules.md и общими стандартами (см. CodingStandards.md).

Содержание:
- Цели и охват
- Типы тестов и размещение
- Практики для слоёв (Domain/Data/Presentation)
- Тестирование корутин и StateFlow
- Моки/фейки и DI (Koin)
- Сеть и персистентность (Ktor/DB/DataStore)
- Снапшоты Compose и UI-паттерны
- Метрики и логирование
- Запуск и интеграция в CI
- Чек-листы качества

## Цели и охват

- Обеспечить корректность бизнес-логики (Domain), стабильность источников данных (Data) и предсказуемость UI-потока (Presentation/MVI).
- Разделять тестирование по слоям и ограничивать внешние зависимости.
- Максимизировать долю unit-тестов в commonMain (переносимость).
- Проверять критические сценарии (ошибки, таймауты, пустые состояния, оффлайн-режим).

## Типы тестов и размещение

- Общие юнит-тесты:
  - shared/src/commonTest/kotlin — Domain/Data (мапперы, use case, репозитории).
  - composeApp/src/commonTest/kotlin — ViewModel и презентационная логика (без платформенной обвязки).
- Платформенные тесты (по необходимости):
  - composeApp/src/androidMain/...UnitTest, composeApp/src/jvmMain/...Test.
  - server/src/test/kotlin — для Ktor-сервера.
- Интеграционные тесты: точечно, с тестовыми реализациями API/DAO.
- Снапшот-тесты UI: опционально для стабильных компонентов Compose.

## Практики по слоям

### Domain
- Тестируем UseCase-ы изолированно от внешних систем:
  - Используем фейковые реализации репозиториев (in-memory/стаб).
  - Покрываем валидные/невалидные входы, граничные случаи.
- Проверяем чистую бизнес-логику и контракты.

### Data
- Мапперы DTO↔Domain:
  - Покрываем nullability, дефолты, некорректные значения.
- Репозитории:
  - При работе с сетью/БД — подменяем API/DAO на фейки/моки.
  - Вызовы через `safeApiCall { ... }`: проверяем конверсию ошибок к DomainException.
- Ktor:
  - Используем тестовые двигатели/перехватчики ответов (MockEngine), проверяем сериализацию.

### Presentation (MVI)
- ViewModel:
  - Инициальное состояние.
  - Реакция на события (Event) → изменение State.
  - Побочные эффекты (если есть) — отдельными потоками/каналами.
- Исключаем UI-фреймворк — тестируем редьюсинг и коррутинную логику через TestScope/TestDispatcher.

## Тестирование корутин и StateFlow

- Использовать kotlinx-coroutines-test:
  - StandardTestDispatcher/TestScope для детерминированной работы.
  - `runTest { ... }` и `advanceUntilIdle()` для контроля планировщика.
- StateFlow:
  - Подписываемся в тесте на `state` и проверяем последовательность/финальные значения.
  - Избегаем ожиданий по времени — используем контролируемые диспетчеры.
- Рекомендации:
  - Инжектировать диспетчеры (при многократном использовании) или использовать TestDispatcher в VM-конструкторе для тестов.

## Моки/фейки и DI (Koin)

- Для модульных тестов предпочтительны фейки (простые in-memory реализации).
- Моки — для проверки взаимодействий/контрактов.
- Koin:
  - В unit-тестах VM/UseCase можно миновать глобальный Koin: конструировать объекты вручную.
  - Для интеграционных сценариев — запускать Koin с тестовыми модулями и `koinTest` утилитами.
- Инварианты DI:
  - Регистрировать зависимости по интерфейсам.
  - Подменять реализации в тестовых модулях без изменения production-кода.

## Сеть и персистентность

- Ktor:
  - MockEngine для стаба ответов, проверка сериализации/десериализации (kotlinx.serialization).
  - Тесты таймаутов/ретраев — через конфигурацию клиента и искусственные задержки (в пределах runTest).
- DB/DataStore:
  - In-memory БД/временные директории.
  - Валидация схем/миграций — отдельные тесты (при наличии миграций).
- Offline:
  - Проверять поведение репозиториев при недоступности сети и наличие fallback из кеша (при наличии кеширования).

## Снапшоты Compose и UI-паттерны

- Для стабильных компонентов — snapshot/скриншот-тесты (опционально).
- ViewModel-ориентированные тесты: проверка State и вызываемых колбэков навигации.
- При подписке использовать `collectAsStateWithLifecycle()` в реальном UI, но в тестах проверять напрямую StateFlow.

## Метрики и логирование

- Логирование:
  - В unit-тестах можно отключать или редиректить Logger.
  - Проверять, что ошибки приводят к ожидаемым событиям/состояниям, а не к падениям.
- Метрики:
  - Валидация инкремента метрик на критических смежных кейсах (по необходимости).

## Запуск и интеграция в CI

- Локально:
  - `./gradlew :shared:allTests`
  - `./gradlew :composeApp:allTests`
  - `./gradlew :server:test`
- В CI:
  - Шаги: сборка, линт, тесты модулей, публикация отчётов.
  - Порог по покрытию (опционально) — сообщать в отчётах.

## Чек-листы качества

Unit-качество:
- [ ] Тесты для UseCase-ов (валидные/граничные/невалидные).
- [ ] Мапперы DTO↔Domain покрыты и проверяют nullability/дефолты.
- [ ] Репозитории: успешные ответы, ошибки сети/парсинга, `safeApiCall` конвертирует в DomainException.
- [ ] ViewModel: инициальный State, реакция на все Event, отсутствие блокировок.

Интеграция:
- [ ] Тестовый Ktor-клиент (MockEngine), тесты таймаутов/ретраев (при наличии).
- [ ] In-memory DB/DAO/DataStore и сценарии чтения/записи.
- [ ] Поведение оффлайн (если кеш/персистентность используется).

Документы и процесс:
- [ ] README/документация обновлены при добавлении тестовых зависимостей/плагинов.
- [ ] Отчёты тестов доступны в CI, сборка “зелёная”.
