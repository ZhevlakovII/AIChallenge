# Правила написания кода (Coding Standards)

Документ формализует правила написания кода в проекте AIChallenge. Основан на AIChallenge-StyleGuide.md и .clinerules/Project-rules.md. Применим для KMP+CMP, Чистой архитектуры, MVI, Koin, Ktor, Coroutines, Kotlinx.serialization.

Содержание:
- Общие принципы
- Архитектурные границы (Presentation/Domain/Data)
- Именование и структура файлов
- Документирование (KDoc, комментарии)
- Стиль кода и форматирование
- Коррутины и StateFlow
- Работа с данными, DTO и мапперами
- Ошибки и исключения
- Логирование
- Тестирование (минимальные правила)
- Коммиты и PR-процесс (Conventional Commits)

## Общие принципы

- Соблюдать Чистую архитектуру, MVI и KMP-изоляцию платформенной специфики.
- Предпочитать неизменяемые структуры данных (data class, copy).
- Явная зависимость через DI (Koin). Реализации скрываются за интерфейсами.
- Минимизировать сайд-эффекты; чистые функции там, где это возможно.
- Прозрачность управления состоянием и однонаправленный поток данных.

## Архитектурные границы

- Presentation:
  - UI-компоненты Compose, ViewModel, `StateFlow` состояния, `Event` (sealed class).
  - Никаких DTO и платформенных типов вне UI-обвязки.
- Domain:
  - Чистые модели и интерфейсы репозиториев, UseCase-ы.
  - Без зависимостей от фреймворков/платформ.
- Data:
  - Репозитории, источники данных (API/БД/кэш), DTO, мапперы.
  - Сетевая логика (Ktor), сериализация (kotlinx.serialization).
  - Конверсия ошибок к доменной модели ошибок.

Запрещено нарушать DIP: Presentation не зависит от Data, Domain не зависит от Data-реализаций.

## Именование и структура файлов

- Классы — UpperCamelCase: `ChatViewModel`, `OpenAIApiImpl`.
- Интерфейсы — без префикса `I`: `OpenAIApi`, `DialogPersistenceRepository`.
- Реализации — суффикс `Impl`: `OpenAIApiImpl`, `SendMessageUseCaseImpl`.
- DTO — суффикс `DTO`: `ChatMessageDTO`, `UsageDTO`.
- UseCase — глагол + существительное: `SendMessageUseCase`.
- Константы — `UPPER_SNAKE_CASE`.
- Раскладка фичи: `features/<feature>/{di,domain,presentation,data}`.
- Платформа-специфика — в `androidMain`/`jvmMain` соответствующих модулей.

## Документирование (KDoc, комментарии)

- KDoc на русском для всех публичных классов/методов/интерфейсов.
- Документировать нетривиальные места, обоснования решений.
- Для ViewModel описывать контракт состояния и событий.

Пример:
```kotlin
/**
 * UseCase отправки сообщения в LLM.
 *
 * Выполняет сетевой запрос через репозиторий и возвращает доменную модель ответа.
 */
interface SendMessageUseCase {
    /**
     * Отправляет текстовое сообщение.
     *
     * @param text Текст сообщения пользователя
     * @return Доменная модель ответа ассистента
     * @throws DomainException В случае сетевых/парсинговых/бизнес-ошибок
     */
    suspend operator fun invoke(text: String): LLMResponse
}
```

## Стиль кода и форматирование

- Kotlin style: отступы 4 пробела (или стиль проекта), максимальная длина строки 120–140 символов.
- Импорты — организованные, без wildcard, если иное не настроено.
- Чистые сигнатуры, явные типы там, где повышается читаемость.
- Рекомендация: линтинг через ktlint/spotless (при добавлении конфигурации в Gradle).
- Инициализировать коллекции безопасно: `emptyList()`, `emptyMap()`.

## Коррутины и StateFlow

- Только structured concurrency.
- В ViewModel:
  - `private val _state = MutableStateFlow(State(...))`
  - `val state: StateFlow<State> = _state.asStateFlow()`
  - Обновление через `_state.update { it.copy(...) }`
- Подписка в UI: `collectAsStateWithLifecycle()`.
- Диспетчеры указывать явно для тяжёлых операций (`withContext(Dispatchers.IO)`), по возможности инжектировать.
- Исключить блокирующие вызовы в Main. Внешние операции оборачивать в корутины.

## Работа с данными, DTO и мапперами

- DTO используются только в Data.
- Мапперы — extension-функции:
  - `fun SomeDTO.toDomain(): SomeDomain`
  - Обрабатывать nullable/дефолты; доменные модели — максимально безопасные.
- Сетевые вызовы/хранилище оборачивать в `safeApiCall { ... }`.

## Ошибки и исключения

- Низкоуровневые ошибки: `RequestError`, `ApiError` (Data).
- Доменная ошибка: `DomainException` (Domain).
- Конверсия ошибок — в Data-слое, UI получает понятные сообщения.
- В UI нельзя выбрасывать “сырые” низкоуровневые исключения.

## Логирование

- Общий `Logger` (shared/common/Logger.kt).
- Уровни: debug/info/error.
- Логировать контекст операций (идентификаторы диалогов/запросов), маскировать секреты.
- Не дублировать избыточные логи, использовать читаемые сообщения.

## Тестирование (минимальные правила)

- Domain/Data: unit-тесты в `shared/src/commonTest/kotlin`.
- UI/ViewModel: тестирование редьюсеров/логики, при необходимости snapshot/compose-тесты в `composeApp/src/commonTest/kotlin`.
- Мапперы: тестировать конверсию, nullability, дефолты.
- Ошибки: проверять, что конверсия к `DomainException` происходит корректно.

## Коммиты и PR-процесс

- Conventional Commits:
  - `feat:`, `fix:`, `docs:`, `refactor:`, `test:`, `chore:`, `build:`, `ci:`
- Один PR — одна логическая задача. Описание включает:
  - Что изменено, почему, ссылки на задачи/документацию.
  - Скриншоты UI (при необходимости).
  - Чек-лист: линт, тесты, сборка зелёная, docs обновлены.
- Ревью: следить за соблюдением архитектурных границ, MVI и KMP-изоляции.
