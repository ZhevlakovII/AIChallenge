# Документ по принципам и стилю проекта AIChallenge

## 1. Архитектурные принципы

### 1.1. Общая архитектура
- Проект следует принципам **чистой архитектуры** с четким разделением на слои:
  - **Presentation**: UI-компоненты, ViewModel, состояния
  - **Domain**: бизнес-логика, use cases, доменные модели
  - **Data**: реализации репозиториев, источники данных, DTO-модели
- Используется **модульный подход** с разделением на feature-модули
- Соблюдается **принцип инверсии зависимостей** (Dependency Inversion Principle)
- Применяется **паттерн MVI** (Model-View-Intent) для UI
- Используется **реактивное программирование** с применением StateFlow

### 1.2. Мультиплатформенность
- Код организован с учетом **Kotlin Multiplatform**
- Общий код выделен в `shared` модуль
- Платформенная специфика изолирована в соответствующих source sets

## 2. Технологический стек

### 2.1. Основные технологии
- **Kotlin Multiplatform**: основной язык программирования
- **Compose Multiplatform**: для создания UI
- **Ktor**: для сетевого взаимодействия
- **Koin**: для внедрения зависимостей
- **Kotlinx.serialization**: для сериализации/десериализации данных
- **Kotlin Coroutines**: для асинхронного программирования

### 2.2. Особенности использования
- Коллекции состояний реализуются с помощью StateFlow
- Асинхронные операции выполняются в корутинах с явным указанием диспетчера
- Используются корутинные скоупы для управления жизненным циклом

## 3. Структура проекта

### 3.1. Модульная организация
- **composeApp**: UI-компоненты, навигация, ViewModels
- **shared**: общий код, доменная логика, репозитории, модели данных
- **server**: серверная часть приложения

### 3.2. Организация фичей
- Каждая фича имеет свой пакет с подпакетами:
  - **di**: модули Koin для внедрения зависимостей
  - **domain**: use cases и доменные модели
  - **presentation**: ViewModels, UI-состояния, события и UI-компоненты
  - **data**: репозитории и источники данных

## 4. Соглашения по именованию и стилю кода

### 4.1. Именование
- **Классы**: UpperCamelCase, отражают назначение (например, `ChatViewModel`)
- **Интерфейсы**: без префикса 'I', описывают функциональность (например, `OpenAIApi`)
- **Реализации интерфейсов**: с суффиксом 'Impl' (например, `OpenAIApiImpl`)
- **DTO-модели**: с суффиксом 'DTO' (например, `ChatMessageDTO`)
- **Use Cases**: глагол + существительное (например, `SendMessageUseCase`)
- **Константы**: UPPER_SNAKE_CASE

### 4.2. Документирование
- KDoc комментарии на **русском языке**
- Документирование всех публичных API, классов и методов
- Документирование неочевидных решений в сложных методах

### 4.3. Стиль кода
- Предпочтение **неизменяемым** структурам данных (data classes, immutable collections)
- Использование **extension-функций** для расширения функциональности
- Обработка ошибок через **специализированные классы ошибок**
- Явное логирование всех ключевых операций и ошибок

## 5. Работа с данными

### 5.1. Модели данных
- Четкое разделение **доменных моделей** и **DTO-моделей**
- Использование **маппера** для преобразования между моделями разных слоев
- Избегание использования DTO в презентационном слое

### 5.2. Хранение данных
- Инкапсуляция логики доступа к данным в **репозиториях**
- Использование **абстракций** для источников данных
- Персистентность данных для поддержки offline-режима

## 6. Взаимодействие с API

### 6.1. Конфигурация
- Использование **интерфейсов** для API-клиентов
- Конфигурирование API-клиентов через DI
- Обработка API-ключей с соблюдением безопасности

### 6.2. Обработка ошибок
- Специализированные классы ошибок для различных сценариев
- Информативные сообщения об ошибках
- Логирование деталей запросов и ответов для отладки

## 7. Состояние и интерфейс пользователя

### 7.1. Управление состоянием
- Использование **UI-моделей состояния** для представления данных в UI
- Однонаправленный поток данных (MVI)
- Обновление UI через StateFlow

### 7.2. Обработка событий
- События от UI обрабатываются через паттерн **событий** (events)
- Четкое разделение между событиями, состоянием и эффектами

## 8. Логирование и отладка

### 8.1. Принципы логирования
- Использование разных уровней логирования (debug, info, error)
- Структурированное логирование с контекстом
- Логирование важных бизнес-событий и ошибок

### 8.2. Диагностика
- Сбор и анализ метрик использования
- Мониторинг потребления ресурсов (токены, сетевые запросы)
